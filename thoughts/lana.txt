 ... LANA Communication description ...

The userlevel API should ideally look like (example snippet in C):

#include <linux/lana.h>

int main(void)
{
	ssize_t ret;
	int sock, err, flags;
	struct sockaddr_lana own, remote;
	char buff[256];
	socklen_t remote_len;
	...
	sock = socket(AF_LANA, SOCK_RAW, 0);
	...
	/*
	 * Here, we tell the kernel our application requirements, i.e.
	 *   MSG_GLOBAL - we do not communicate locally
	 *   MSG_RELIABLE - we want to have a 'TCP-like' data transfer
	 *   MSG_CONFIDENTIAL - we want to communicate encrypted
	 * Applied to _sendto_, at leat.
	 */
	flags = MSG_GLOBAL | MSG_RELIABLE | MSG_CONFIDENTIAL;
	...
	/*
	 * Here, we give ourselves a context and address within this
	 * context, separated by '@': address@context
	 */
	own.sa_family = AF_LANA;
	strlcpy(own.sa_address, "daniel.borkmann@ch.ethz.csg.chat",
		sizeof(own.sa_address));
	bind(sock, (struct sockaddr_in *) &own, sizeof(own));
	...
	/* If "ch.ethz.csg.chat" didn't exist before, it exists now. */
	...
	/*
	 * We are receiving data from others within "ch.ethz.csg.chat".
	 * Messages may _not_ come from i.e.
	 * "ch.ethz.csg.chat.meeting.2012.07.20" or "ch.ethz.csg.chat.misc"
	 * since these are more fine-grained subgroups of "ch.ethz.csg.chat".
	 * Since we belong to "ch.ethz.csg.chat", we _may_ send messages
	 * to one of these these groups, but not vice versa.
	 */
	remote_len = sizeof(remote);
	recvfrom(sock, buff, sizeof(buff), 0, (struct sockaddr *) remote,
		 &remote_len);
	...
	/*
	 * We are now sending a message to Ariane Keller within
	 * "ch.ethz.csg.chat". If the context is "above" "ch.ethz.csg.chat"
	 * we will get an error from the kernel, since we've bound to this
	 * context.
	 */
	memset(&remote, 0, sizeof(remote));
	remote.sa_family = AF_LANA;
	strlcpy(remote.sa_address, "ariane.keller@ch.ethz.csg.chat",
		sizeof(remote.sa_address));
	memset(buff, 0, sizeof(buff));
	strlcpy(buff, "hello ariane!", sizeof(buff));
	flags = MSG_GLOBAL | MSG_RELIABLE | MSG_CONFIDENTIAL;
	sendto(sock, buff, strlen(buff) + 1, flags,
	       (struct sockaddr *) &remote, sizeof(remote));
	...
	/*
	 * Broadcast example following next.
	 * In general, few special chars are allowed, but no regex!
	 * Special char:
	 *    '*'                  - all
	 *    '+' followed by name - multicast group, i.e.
	 *                           "+lunch@ch.ethz.csg.chat"
	 *    '.'                  - context level separator
	 *
	 * Allowed chars in names / addresses: [a-z0-9]
	 */
	...
	memset(&remote, 0, sizeof(remote));
	remote.sa_family = AF_LANA;
	strlcpy(remote.sa_address, "*@ch.ethz.csg.chat",
		sizeof(remote.sa_address));
	memset(buff, 0, sizeof(buff));
	strlcpy(buff, "hello to all!", sizeof(buff));
	flags = MSG_GLOBAL | MSG_RELIABLE;
	sendto(sock, buff, strlen(buff) + 1, flags,
	       (struct sockaddr *) &remote, sizeof(remote));
	...
	close(sock);
	return 0;
}

Things that do not concern the userspace:
  * Feature implementation of the flags for sendto
  * Whether IPv4 / IPv6 / ... should be used or is used at all
  * We just want to define our requirements, send and receive data

Facts / Questions to solve:
  * Contexts like "ch.ethz.csg.chat" are volatile?
  * How to route within "ch.ethz.csg.chat" and between lower contexts
    if i.e. one user is located in Switzerland and the other in Japan?
  * Use of DHTs for routing information?

